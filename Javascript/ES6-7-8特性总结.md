# ES6 入门总结

## Symbol

ES5 的对象属性名都是字符串，容易造成属性名的冲突。
比如，你使用一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突，如何解决？
需要有一种机制，保证每个属性的名字都是独一无二的，从根本上防止命名冲突。

ES6 的 Symbol 机制就是引入了一种新的原始数据类型 Symbol，表示独一无二的值。Symbol 的值是通过 Symbol 函数生成。它是一个原始类型，不需要 new 运算符。

Symbol 可以用来实现模块的 Singleton 模式。

## 函数的新特性

1.  参数默认值；
2.  rest 参数： 把离散的函数参数聚合成一个数组；
3.  扩展运算符(...)：rest 的逆运算， 把一个数组分散展开成单个的变量；
4.  箭头函数；
5.  尾调用： 存在于函数式编程，通俗理解，就是函数的最后一句话是不是一个函数。尾调用：提升性能

## 数组的扩展

1. `Array.from()`: 把 array like 和可遍历（iterable）的对象转成为真正的数组；实例应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。`Array.from()`都可以将它们转为真正的数组；
2. `Array.of()`: `Array.of()`可以将一组值，转换为数组，这个函数主要是为了弥补数组构造函数 Array()的不足；
3. 数组实例的`find()`和`findIndex()`方法，它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为`true`的成员，然后返回该成员，没有符合条件的成员，则返回`undefined`，`findIndex()`和`find()`方法类似，返回的是成员的下标或者`-1`。
4. 数组实例的`fill()`方法使用给定值，填充一个数组；
5. 数组实例的`entries()`，`keys()`和`values()` 用于遍历数组，它们都返回一个遍历器对象，可以使用`for...of`循环进行遍历；
6. 数组实例的`includes()`方法：返回一个 boolean，表示某个数组是否包含给定的值，与字符串的`includes()`方法类似；

## 对象的扩展和新增方法

### 对象的扩展

1. 属性的简洁表示法；
2. 属性名表达式；
3. 方法的 name 属性：如果对象的方法使用了取值函数`getter`和存值函数`setter`，则`name`属性不是在该方法上面，而是在该方法的属性描述对象的`get`和`set`属性上面，返回值是方法名前加上`set`和`get`。

## 