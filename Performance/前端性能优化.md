# 从浏览器加载一个url的过程谈前端性能优化
## WebApp性能优化
1. 资源加载优化
2. 浏览器缓存机制利用
3. DOM树构建与DOM操作的合理规避
4. 网页排版和渲染过程
5. 回流与重绘的考量

## 从输入URL到页面加载完成，发生了什么？
### 加载过程 DNS->TCP->DOM downloaded
1. DNS解析 -> IP地址
2. 建立TCP连接
3. 抛出HTTP请求
4. 服务器处理HTTP请求，返回HTTP响应
5. 浏览器拿到响应数据，解析响应内容，把解析结果展示给用户
### 执行脚本 ，渲染过程(rendering Page -> scripting -> waiting user)
1. 解析HTML文件
2. 渲染CSS，HTML body, 执行JS脚本
3. 等待用户交互...

## 页面加载过程的优化策略
### 网络请求阶段
1. DNS 解析花时间，尽量减少解析次数或者把解析前置？
    - 域名收敛
    - DNS缓存
    - DNS prefetch
    - 浏览器对某个域名并发数是有上限的
    - 域名分区：突破并行限制，避免传输过多的cookie
2. HTTP 请求慢？
    - 开启gzip，压缩HTTP body
    - 减少或合并http请求数：使用前端工程化工具（如webpack)进行文件合并，优化，压缩和混淆。
    - 升级HTTP协议，HTTP/1.1 -> HTTP/2 (SPDY)
3. 资源所在的服务器是不是越近越好？
    部署时，把静态资源放到离我们更近的CDN上，与图片CDN分开；

### 图片加载策略优化（重中之重）
> 图片优化的核心：寻求图片质量与性能之间的平衡点

### 缓存策略 - 利用浏览器存储
4. 浏览器缓存： cookie, localStorage, sessionStorage, serviceWorker;
5. HTTP缓存： 
   1. 服务端客户端协商的缓存流程；
   2. HTTP Header: cache-control
      1. max-age
      2. private
      3. public 缓存设备： 如CDN
      4. no-cache
      5. no-store
   3. HTTP Header: Expires 指定资源到期时间，是服务器的具体时间点。
   4. http code = 200, 304  from memory cache / from disk cache / from service worker


## 浏览器存储
### cookie
HTTP请求无状态，所以需要cookie去维护客户端状态。
cookie 用于浏览器端和服务器的交互，客户端自身数据的存储。

#### cookie的生成方式： 
- http response header中的set-cookie
- js中可以通过document.cookie 可以读写cookie
- expire 过期时间

#### cookie存储的限制
- 作为浏览器存储，大小4kb左右
- 需要设置过期时间expire
- 处于安全考虑，cookiebu允许js读写，http only
- cookie 存储逐渐被localstorage取代
- cookie 中相关域名下面，cdn的流量损耗 （解决方案：cdn域名和主站域名是分开的）

### LocalStorage
- HTML5设计出来专门用于浏览器存储
- 大小5M左右
- 仅在客户端使用，不和服务端进行通信
- 接口封装较好
- 浏览器本地缓存方案
- sessionStorage

### Service Workers
查看service worker: chrome://inspect/#service-workers

### 防抖与节流函数适用的业务场景
- debounce 防抖函数
    - search 搜索联想，用户在不断输入值时，用防抖来节约请求资源
    - window触发resize的时候，不断调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次

- throttle 节流函数
    - 鼠标不断点击触发，mousedown(单位时间内只触发一次)
    - 监听滚动事件，比如是否滑到底自动加载更多，用throttle来判断

# Web性能优化

> 性能优化的第一步，就是合理使用性能分析工具。  
> 性能优化的意义在于保留用户，提升转化率，增强用户体验。  
> Performance is about retaining users and improving conversions.

Web性能指标：（RAIL性能模型）
1. Response: 立即响应用户，在100ms内确认用户输入；
2. Animation:(>=60fps) JavaScript->Style->Layout->Paint->Composite；
3. Idle: 最大程度增加主线程的空闲时间, 尽可能的减少预加载的数据；
4. Load:（1秒钟之内） 最大限度缩短加载时间，优化关键渲染路径以取消阻止渲染；

google的Web Develop Tools：
chrome devtools，lighthouse，puppeteer，workbox，chrome user experience report；

1. 谨慎引入第三方库，考虑第三方库是否有引入必要。例如bootstrap，移动端引入复杂的第三方库会增加浏览器解析负担和开销;
2. Flexbox和Grid就可以构建简洁，响应式的UI界面;
3. 节省网络资源，Http Caching，升级到HTTP/2;
4. 图片优化，压缩图片大小，或者采用SVG图片;

## Loading Performance
 

## Rendering Performance

## 浏览器重绘与回流
reflow -> repaint -> composite

### 回流 (reflow) （是否需要重新 measure layout 计算布局）
当render tree 渲染树中的一部分或全部因为元素的尺寸，布局，display等属性的改变而需要重新构建，称为回流。

### 重绘 (repaint)
当render tree 渲染树中一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局，比如background-color，称为重绘


