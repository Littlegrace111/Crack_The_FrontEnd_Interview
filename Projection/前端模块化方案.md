# 前端工程化解决方案

> 工程化：压缩，混淆，打包，签名，部署；

## JavaScript模块化方案

### 早期模块化方案：
全局变量和命名空间  
- 基于同一个全局变量，各模块按照自己的命名空间进行挂载，一般挂载在window上；  
- 模块内部一般通过简单的自执行函数实现局部作用域，避免污染全局作用域。

**缺点：** 

1. 依赖全局变量，污染全局作用域，安全性得不到保障。
2. 依赖约定命名空间来避免冲突；
3. 手动管理依赖顺序；

### AMD
Asynchronous Module Definition 模块和它的依赖可以异步加载，非常适用于浏览器环境。
requireJS是AMD规范的一种通用实现。

**AMD优点：**
1. 仅需在全局环境中定义require和define，不需要其他全局变量；
2. 通过文件路径或自己声明的模块名定位模块；
3. 模块实现中声明依赖，以来的加载与执行均由加载器操作；
4. 提供了打包工具自动分析依赖并合并；

**AMD缺点：**  
不怎么简介的module使用方式，第三方库使用时需要重复繁琐的配置；

### CommonJS
Node.js采用的模块化标准，使用require方法加载模块，模块以同步的方式加载。
一个单独文件就是一个模块，每个模块都有一个独立作用域，该模块内部定义的变量无法被其他模块读取。
模块输出，只有一个出口module.export对象，把输出的内容放到该对象。

**CommonJS优点：**
1. CommonJS规范本身不适合浏览器环境，但可以转换后在浏览器中执行；
2. 相比AMD模块格式，CommonJS的模块格式更简洁，可以实现前后端代码共用（node.js）;

### ES6模块：
基于ES6的语法，可以天然实现模块化；

### JavaScript包管理工具
npm, Bower, etc.

### 任务流工具
grunt, gulp，在linux或macOS系统上可以用shell脚本代替，或者使用node脚本也可以代替；

### 模块打包工具
- webpack: 是一个module bundler模块打包工具，它支持编译ES6模块，兼容打包AMD和CommonJS的模块，同时还支持code splitting，css，图片等；
- browserify: 可将CommonJS规范的模块转换成浏览器可运行代码;

### webpack
Webpack是用来编译，打包js模块的。

全局安装webpack
npm install -g webpack
touch webpack.config.js

webpack
- 把前端工程的所有文件js,png,css,json 等看成一个模块
- 分析其依赖关系

