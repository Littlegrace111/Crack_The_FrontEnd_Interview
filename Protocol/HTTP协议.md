## HTTP 协议
无连接， 无状态。
请求报文：请求行，请求头（request-header，key-value值), 空行（标识header结束，body开始），请求体（request-body）;
响应报文：状态行，响应头(response-header)，空行，响应体（response-body);

### HTTP 方法
- GET : 获取资源
- POST : 传输资源
- PUT : 更新资源
- DELETE : 删除资源（正常业务中不太使用）
- HEAD : 获得报文首部

#### POST 和 GET 的区别
- Get 参数通过URL传递，POST放在Request body 中
- Get 在浏览器回退时是无害的，POST会再次提交请求
- Get 请求默认会被浏览器主动缓存，POST不会，除非手动设置
- Get 请求只能进行url编码，而POST支持多种编码方式
- Get 请求参数会被完整保留在浏览器的历史记录里，而POST中的参数不会被保留
- Get 请求在URL中传送的参数是有长度限制的，而POST没有限制
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制
- GET 比 POST更不安全，不能用来传输敏感信息

#### HTTP状态码
- 1xx: 指示信息 - 表示请求已接收，继续处理
- 2xx: 成功 - 表示请求已被成功接收
    206 partial content: 客户端发送了一个带有Range头的GET请求，服务器完成了它。经常使用在流媒体中，请求一个音频或视频播放地址；
- 3xx: 重定向 - 要完成请求必须要进行更进一步操作
    301 move permanently(永久重定向); 302 Found(临时转移至新的url); 304 Not Modified(使用浏览器缓存);
- 4xx: 客户端错误 - 请求有语法错误或参数错误等无法实现
    400 Bad Request; 401 Unauthorized; 403 Forbidden; 404 Not Found; 
- 5xx: 服务端错误 - 服务器未能实现合法请求
    500 Internal Server Error; 503 Server Unavailable;

#### 浏览器强制使用HTTPS协议
重定向： 访问HTTP站点，跳转到HTTPS；
避免这种跳转，可以使用**HSTS策略**，就是告诉浏览器，以后访问这个站点必须使用HTTPS协议访问，让浏览器帮忙做转换，而不是请求到了服务端，才知道要转换。
只需要在响应头部加上`Strict-Transport-Security: max-age=31536000`。

### HTTP 长连接
HTTP协议是一种无状态的面向连接的协议，HTTP长连接的意思是，多个HTTP请求是否复用一个TCP连接。
在HTTP/1.0中默认使用短连接。而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接，会在响应头加入这行代码：`Connection: keep-alive`。

在使用长连接的情况下，当一个网页打开完成之后，客户端和服务端之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器是，会复用这条TCP连接。`keep-alive`不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache，Nginx等）中设定这个时间。

实现长连接需要客户端和服务端都支持长连接。
长连接的优点就是可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。
短连接的优点就是对于服务器管理来说较为简单，存在的连接都是可用连接，不需要额外的控制手段。  

### HTTP 管线化
HTTP 管线化可以克服同域并行请求限制带来的阻塞，它建立在持久连接之上，是把所有请求一并发给服务端，服务端需要按照顺序一个一个响应，而不是等到一个响应回来才能发下一个请求，这样就节省了很多请求到服务器的时间。

### HTTP/1.1
头信息是文本（ASCII编码），数据体可以使文本，或者二进制。

### SPDY 协议 HTTP2 前生
HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧“frame：头信息和数据帧。

### HTTP/2 特点
1. 二进制协议，可扩展，方便定义额外帧；
2. 多工（Multiplexing）  
    复用TCP连接，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，避免”对头堵塞“。
    举例， 在一个TCP连接里，服务器同时收到request A 和request B，先回应A，发现非常耗时，于是就发送A请求已经处理好的部分，接着回应B，完成后，继续A请求剩下部分。
3. 数据流
    数据包是不按照顺序发送的，同一个连接里面连续的数据包，可能属于不同回应。
    需要对数据包做标记，指出属于哪个回应。
    HTTP/2 将每个请求或回应的所有数据包，称为一个数据流stream。每个数据流都有一个unique编号。
    数据包发送，必须标记数据流ID，用来区分属于哪个数据流。客户端发出的stream，ID为奇数，服务器发出的，ID为偶数。
    数据流发送到一半的时候，可以发送信号RST_STREAM帧，取消这个数据流。
    HTTP/1.1版本取消数据流的唯一方法，就是关闭TCP连接。
    HTTP/2 可以取消某一次请求，同时保证底层的TCP连接还打开
4. 头信息压缩 header compresssion
    HTTP协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如cookie，比如user agent。
    HTTP/2针对这一点做了优化，引入头信息压缩机制header compression。
    另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一张索引，以后就不发送同样字段，只发送索引号，提高速度。
5. 服务器推送：server push
    允许服务器未经请求，主动向客户端发送资源。
    例如，客户端请求一个网页，这个网页里包含很多静态资源。正常情况，客户端必须受到网页后，解析http源码，发现静态资源，再去请求静态资源。
    HTTP/2，服务器可以预期到客户端请求网页后，可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端。